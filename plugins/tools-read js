// ============================================
// COMANDO: READ (Para ver imÃ¡genes de vista Ãºnica de otros usuarios)
// Archivo: read.js
// ============================================
async function handler(m, { conn, quoted }) {
    // Verificar si hay mensaje citado
    if (!quoted) {
        return m.reply(`ğŸŒ¸ *ğ—ªğ—”ğ—šğ—¨ğ—¥ğ—¨ ğ—•ğ—¢ğ—§ ğŸŒ¸*\n\n` +
                      `ğŸ‘ï¸ *VISUALIZADOR DE VISTA ÃšNICA*\n\n` +
                      `âŒ *Responde a una imagen/video de vista Ãºnica de cualquier usuario*\n\n` +
                      `*Uso:*\n` +
                      `1. Alguien envÃ­a una foto/video de vista Ãºnica\n` +
                      `2. TÃº respondes a ese mensaje con .read\n` +
                      `3. Yo reenviarÃ© el contenido para que todos puedan verlo\n\n` +
                      `âš ï¸ *Funciona con imÃ¡genes/videos de cualquier usuario*\n` +
                      `âœ¨ *Comandos:* .read .leer .ver`);
    }

    // Verificar si el mensaje citado es de vista Ãºnica
    if (!quoted.viewOnce) {
        return m.reply('âŒ Este mensaje no es de vista Ãºnica.\nSolo funciona con imÃ¡genes/videos que se ven una vez (vista Ãºnica).');
    }

    // Verificar que sea imagen o video
    const isImage = quoted.mtype === 'imageMessage';
    const isVideo = quoted.mtype === 'videoMessage';
    
    if (!isImage && !isVideo) {
        return m.reply('âŒ Solo puedo leer imÃ¡genes o videos de vista Ãºnica.');
    }

    const senderName = quoted.pushName || 'Usuario';
    const loadingMsg = await m.reply(`ğŸ”„ Recuperando contenido de ${senderName}...`);

    try {
        // Descargar el archivo
        const buffer = await quoted.download();
        const fileSize = (buffer.length / 1024 / 1024).toFixed(2);
        
        // InformaciÃ³n para el pie de foto
        const caption = `ğŸŒ¸ *ğ—ªğ—”ğ—šğ—¨ğ—¥ğ—¨ ğ—•ğ—¢ğ—§ ğŸŒ¸*\n\n` +
                       `âœ… *CONTENIDO RECUPERADO*\n\n` +
                       `ğŸ‘¤ *Enviado por:* ${senderName}\n` +
                       `ğŸ“Š *TamaÃ±o:* ${fileSize} MB\n` +
                       `ğŸ‘ï¸ *Recuperado por:* @${m.sender.split('@')[0]}\n` +
                       `âœ¨ *Ahora todos pueden ver este contenido*`;

        // Enviar el contenido recuperado
        if (isImage) {
            await conn.sendMessage(m.chat, {
                image: buffer,
                caption: caption,
                mentions: [m.sender]
            }, { quoted: m });
        } else if (isVideo) {
            await conn.sendMessage(m.chat, {
                video: buffer,
                caption: caption,
                mentions: [m.sender]
            }, { quoted: m });
        }
        
        // Eliminar mensaje de carga
        await conn.sendMessage(m.chat, { delete: loadingMsg.key });
        
        // ReacciÃ³n de confirmaciÃ³n
        try {
            await conn.sendReaction(m.chat, m.key, 'âœ…');
        } catch {}
        
    } catch (error) {
        console.error('Error en comando read:', error);
        
        // Mensaje de error especÃ­fico
        let errorMessage = `âŒ *Error al recuperar el contenido*\n\n`;
        
        if (error.message.includes('download') || error.message.includes('timeout')) {
            errorMessage += `*Posible causa:*\n`;
            errorMessage += `â€¢ El archivo ya expirÃ³\n`;
            errorMessage += `â€¢ No se pudo descargar el contenido\n`;
            errorMessage += `â€¢ El mensaje es muy antiguo\n\n`;
            errorMessage += `ğŸ’¡ *Intenta responder mÃ¡s rÃ¡pido al mensaje*`;
        } else if (error.message.includes('media') || error.message.includes('type')) {
            errorMessage += `*Posible causa:* Tipo de archivo no compatible\n\n`;
            errorMessage += `ğŸ“¸ *Soportado:* ImÃ¡genes (JPG, PNG, GIF)\n`;
            errorMessage += `ğŸ¬ *Soportado:* Videos (MP4, etc.)`;
        } else {
            errorMessage += `*Error tÃ©cnico:* ${error.message}\n\n`;
            errorMessage += `ğŸ”„ *Reporta el problema si persiste*`;
        }
        
        await m.reply(errorMessage);
        
        // Intentar eliminar mensaje de carga
        try {
            await conn.sendMessage(m.chat, { delete: loadingMsg.key });
        } catch {}
        
        // ReacciÃ³n de error
        try {
            await conn.sendReaction(m.chat, m.key, 'âŒ');
        } catch {}
    }
}

handler.help = ['read'];
handler.tags = ['herramientas'];
handler.command = ['read', 'leer', 'ver', 'viewonce'];
handler.group = true;
handler.limit = false;

export default handler;