import fetch from 'node-fetch';

const API_KEY = 'stellar-SSfb2OPw';
const API_URL = 'https://rest.alyabotpe.xyz/stalking/github';

async function handler(m, { text, conn }) {
    if (!text) {
        return m.reply('âŒ Ingresa un usuario de GitHub\nEjemplo: .stg octocat');
    }

    const username = text.trim();
    
    // Mensaje de espera
    const waitMsg = await m.reply('ğŸ” Buscando informaciÃ³n en GitHub...');
    
    try {
        // Hacer peticiÃ³n a la API
        const url = `${API_URL}?username=${encodeURIComponent(username)}&key=${API_KEY}`;
        console.log('URL solicitada:', url);
        
        const response = await fetch(url);
        const responseText = await response.text();
        
        console.log('Status:', response.status);
        console.log('Respuesta completa:', responseText.substring(0, 500));
        
        // Intentar parsear JSON
        let data;
        try {
            data = JSON.parse(responseText);
        } catch (jsonError) {
            console.log('No es JSON vÃ¡lido:', responseText.substring(0, 200));
            throw new Error('La API no devolviÃ³ JSON vÃ¡lido');
        }
        
        console.log('Datos parseados:', JSON.stringify(data, null, 2));
        
        // Verificar estructura de respuesta
        if (!data) {
            throw new Error('No se recibieron datos');
        }
        
        // Si hay error en la respuesta
        if (data.error || data.status === false) {
            throw new Error(data.message || data.error || 'Usuario no encontrado');
        }
        
        // Extraer datos del usuario
        const userData = data.result || data.data || data;
        
        // Si no hay datos bÃ¡sicos
        if (!userData.login) {
            throw new Error('Perfil no encontrado o datos incompletos');
        }
        
        // Construir mensaje segÃºn lo que devuelva la API
        let message = `*ğŸ™ INFORMACIÃ“N DE GITHUB ğŸ™*\n\n`;
        message += `*ğŸ‘¤ Usuario:* ${userData.login || 'N/A'}\n`;
        
        if (userData.name) message += `*ğŸ“› Nombre:* ${userData.name}\n`;
        if (userData.bio) message += `*ğŸ“ Bio:* ${userData.bio}\n`;
        if (userData.location) message += `*ğŸ“ UbicaciÃ³n:* ${userData.location}\n`;
        if (userData.company) message += `*ğŸ¢ CompaÃ±Ã­a:* ${userData.company}\n`;
        if (userData.blog) message += `*ğŸŒ Blog:* ${userData.blog}\n`;
        if (userData.email) message += `*ğŸ“§ Email:* ${userData.email}\n`;
        
        message += `\n*ğŸ“Š ESTADÃSTICAS*\n`;
        message += `*ğŸ“ Repos pÃºblicos:* ${userData.public_repos || 0}\n`;
        message += `*ğŸ“ Gists:* ${userData.public_gists || 0}\n`;
        message += `*ğŸ‘¥ Seguidores:* ${userData.followers || 0}\n`;
        message += `*ğŸ‘£ Siguiendo:* ${userData.following || 0}\n`;
        
        if (userData.created_at) {
            const created = new Date(userData.created_at).toLocaleDateString();
            message += `\n*ğŸ“… Creado:* ${created}\n`;
        }
        
        if (userData.html_url) {
            message += `\n*ğŸ”— URL:* ${userData.html_url}`;
        }
        
        // Enviar mensaje
        await m.reply(message);
        
        // Si hay avatar, enviarlo tambiÃ©n
        if (userData.avatar_url) {
            try {
                await conn.sendMessage(m.chat, {
                    image: { url: userData.avatar_url },
                    caption: `ğŸ–¼ï¸ Avatar de ${userData.login}`
                });
            } catch (avatarError) {
                console.error('Error enviando avatar:', avatarError);
            }
        }
        
        // Eliminar mensaje de espera
        await conn.sendMessage(m.chat, { delete: waitMsg.key });
        
    } catch (error) {
        console.error('Error GitHub stalking:', error);
        
        // Eliminar mensaje de espera
        try {
            await conn.sendMessage(m.chat, { delete: waitMsg.key });
        } catch {}
        
        // Mensaje de error segÃºn el tipo de error
        let errorMessage = `âŒ *Error al buscar ${username}*\n\n`;
        
        if (error.message.includes('not found') || error.message.includes('no encontrado')) {
            errorMessage += `El usuario *${username}* no existe en GitHub.\n`;
            errorMessage += `Verifica la ortografÃ­a o prueba con otro usuario.`;
        } else if (error.message.includes('JSON')) {
            errorMessage += `La API devolviÃ³ una respuesta inesperada.\n`;
            errorMessage += `Intenta nuevamente o verifica la conexiÃ³n.`;
        } else if (error.message.includes('timeout') || error.message.includes('network')) {
            errorMessage += `Problema de conexiÃ³n con la API.\n`;
            errorMessage += `Intenta nuevamente en unos minutos.`;
        } else {
            errorMessage += `Error: ${error.message}`;
        }
        
        await m.reply(errorMessage);
    }
}

// VersiÃ³n alternativa para debug
async function handlerDebug(m, { text, conn }) {
    if (!text) return m.reply('âŒ Escribe un usuario');
    
    const username = text.trim();
    const waitMsg = await m.reply('ğŸ”„ Debugging API...');
    
    try {
        const url = `${API_URL}?username=${encodeURIComponent(username)}&key=${API_KEY}`;
        console.log('ğŸ”— URL:', url);
        
        const response = await fetch(url);
        const status = response.status;
        const headers = Object.fromEntries(response.headers.entries());
        const responseText = await response.text();
        
        console.log('ğŸ“Š Status:', status);
        console.log('ğŸ“‹ Headers:', headers);
        console.log('ğŸ“„ Respuesta (primeros 1000 chars):', responseText.substring(0, 1000));
        
        // Mostrar info de debug al usuario
        let debugMessage = `*ğŸ”§ DEBUG GITHUB API*\n\n`;
        debugMessage += `*ğŸ‘¤ Usuario:* ${username}\n`;
        debugMessage += `*ğŸ“¡ Status:* ${status}\n`;
        debugMessage += `*ğŸ“„ Content-Type:* ${headers['content-type'] || 'N/A'}\n`;
        debugMessage += `*ğŸ“ Longitud:* ${responseText.length} caracteres\n\n`;
        
        // Mostrar parte de la respuesta
        const preview = responseText.substring(0, 500);
        debugMessage += `*ğŸ“‹ Preview:*\n\`\`\`${preview}...\`\`\`\n\n`;
        
        // Intentar parsear si es JSON
        try {
            const data = JSON.parse(responseText);
            debugMessage += `*âœ… Es JSON vÃ¡lido*\n`;
            debugMessage += `*ğŸ” Estructura:*\n\`\`\`${JSON.stringify(data, null, 2).substring(0, 300)}...\`\`\``;
        } catch {
            debugMessage += `*âŒ No es JSON vÃ¡lido*\n`;
        }
        
        await m.reply(debugMessage);
        await conn.sendMessage(m.chat, { delete: waitMsg.key });
        
    } catch (error) {
        console.error('Debug error:', error);
        await m.reply(`âŒ Debug error: ${error.message}`);
        try { await conn.sendMessage(m.chat, { delete: waitMsg.key }); } catch {}
    }
}

handler.help = ["stg <usuario>"];
handler.tags = ["stalk"];
handler.command = ["stg", "github", "gitstalk"];
handler.group = true;

// Comando de debug separado
const debugHandler = {
    async handler(m, { text }) {
        const username = text || 'octocat';
        const url = `${API_URL}?username=${encodeURIComponent(username)}&key=${API_KEY}`;
        
        const wait = await m.reply('ğŸ”„ Probando API...');
        
        try {
            const res = await fetch(url);
            const textRes = await res.text();
            
            const message = `*DEBUG GITHUB API*\n\n` +
                           `URL: ${url}\n` +
                           `Status: ${res.status}\n` +
                           `Length: ${textRes.length}\n\n` +
                           `First 300 chars:\n\`\`\`${textRes.substring(0, 300)}\`\`\``;
            
            await m.reply(message);
            await wait.delete();
            
        } catch (error) {
            await m.reply(`âŒ Error: ${error.message}`);
            try { await wait.delete(); } catch {}
        }
    },
    command: ['stgdebug', 'githubdebug']
};

export default handler;